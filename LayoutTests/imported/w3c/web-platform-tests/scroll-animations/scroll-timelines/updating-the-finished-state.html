<!DOCTYPE html>
<meta charset=utf-8>
<title>Updating the finished state</title>
<link rel="help" href="https://drafts.csswg.org/web-animations/#updating-the-finished-state">
<script src="/resources/testharness.js"></script>
<script src="/resources/testharnessreport.js"></script>
<script src="/web-animations/testcommon.js"></script>
<script src="testcommon.js"></script>
<style>
.scroller {
  overflow: auto;
  height: 100px;
  width: 100px;
  will-change: transform;
}

.contents {
  height: 1000px;
  width: 100%;
}
</style>
<body>
<script>
'use strict';

promise_test(async t => {
  const anim = createScrollLinkedAnimation(t);
  // Wait for new animation frame which allows the timeline to compute new
  // current time.
  await waitForNextFrame();
  anim.cancel();
  anim.currentTime = CSS.percent(150);
  // Trigger a change that will cause the "update the finished state"
  // procedure to run.
  anim.currentTime = CSS.percent(50);
  assert_percents_equal(anim.currentTime, 50,
      'The animation hold time should not be updated');
  assert_equals(anim.startTime, null,
      'The animation start time should not be updated');
}, 'Updating the finished state when start time is unresolved and did seek = ' +
   'true');

// promise_test(async t => {
//   const animation = createScrollLinkedAnimation(t);
//   const scroller = animation.timeline.source;
//   const maxScroll = scroller.scrollHeight - scroller.clientHeight;
//
//   animation.play();
//
//   scroller.scrollTop = maxScroll;
//
//   await animation.finished;
//
//   scroller.scrollTop = 0;
//
//   await waitForNextFrame();
//
//   animation.play();
//
//   scroller.scrollTop = maxScroll;
//
//   await animation.finished;
// }, 'Animation finish event is fired again after replaying from start');

async_test(t => {
  const animation = createScrollLinkedAnimation(t);
  const scroller = animation.timeline.source;
  const maxScroll = scroller.scrollHeight - scroller.clientHeight;

  animation.play();

  animation.onfinish = event => {
    // Waiting a beat here, even just a setTimeout, fixes the issue.
    console.log(animation.currentTime);
    scroller.scrollTop = 0;
    console.log(animation.currentTime);
    window.requestAnimationFrame(function() {
        console.log(animation.currentTime);
      animation.play();
      console.log(animation.currentTime);
      animation.onfinish = event => {
          console.log(animation.currentTime);
        t.done();
      };
      console.log(animation.currentTime);
      scroller.scrollTop = maxScroll;
      console.log(animation.currentTime);
    });
  };
  scroller.scrollTop = maxScroll;
}, 'Animation finish event is fired again after replaying from start');

</script>
</body>
